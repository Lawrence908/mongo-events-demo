// MongoDB Playground - Transactions
// This file demonstrates MongoDB transaction capabilities

// Use the eventdb database
use('eventdb');

// Note: Transactions require a replica set or sharded cluster
// These examples show the structure but may not work in a standalone MongoDB instance

// 1. Basic transaction structure (JavaScript)
// This would be run in a MongoDB driver, not in the playground
/*
const session = client.startSession();
try {
    session.startTransaction();
    
    // Decrement available seats
    const eventResult = db.events.updateOne(
        { "_id": ObjectId("..."), "seatsAvailable": { $gt: 0 } },
        { $inc: { "seatsAvailable": -1 } },
        { session: session }
    );
    
    if (eventResult.modifiedCount === 0) {
        throw new Error("No seats available");
    }
    
    // Create ticket
    const ticketResult = db.tickets.insertOne({
        "eventId": ObjectId("..."),
        "userId": ObjectId("..."),
        "pricePaid": 100.00,
        "status": "active",
        "purchasedAt": new Date()
    }, { session: session });
    
    session.commitTransaction();
    print("Transaction committed successfully");
} catch (error) {
    session.abortTransaction();
    print("Transaction aborted:", error.message);
} finally {
    session.endSession();
}
*/

// 2. Simulate transaction logic with findAndModify
// This simulates the atomic operations that would be in a transaction

// Check if event has available seats and decrement
db.events.findAndModify({
    query: { 
        "_id": ObjectId("507f1f77bcf86cd799439011"),
        "seatsAvailable": { $gt: 0 }
    },
    update: { $inc: { "seatsAvailable": -1 } },
    new: true
});

// 3. Create ticket record
db.tickets.insertOne({
    "eventId": ObjectId("507f1f77bcf86cd799439011"),
    "userId": ObjectId("507f1f77bcf86cd799439012"),
    "pricePaid": 100.00,
    "status": "active",
    "purchasedAt": new Date()
});

// 4. Check transaction consistency - verify seat count
db.events.findOne(
    { "_id": ObjectId("507f1f77bcf86cd799439011") },
    { "title": 1, "seatsAvailable": 1 }
);

// 5. Check ticket was created
db.tickets.findOne(
    { "eventId": ObjectId("507f1f77bcf86cd799439011") },
    { "pricePaid": 1, "status": 1, "purchasedAt": 1 }
);

// 6. Simulate rollback - restore seat count
db.events.updateOne(
    { "_id": ObjectId("507f1f77bcf86cd799439011") },
    { $inc: { "seatsAvailable": 1 } }
);

// 7. Remove ticket (rollback)
db.tickets.deleteOne(
    { "eventId": ObjectId("507f1f77bcf86cd799439011") }
);

// 8. Check for race conditions - multiple concurrent purchases
// This would be handled by the application layer with proper locking

// 9. Transaction with multiple collections
// Simulate updating event, creating ticket, and logging activity

// Update event
db.events.updateOne(
    { "_id": ObjectId("507f1f77bcf86cd799439011") },
    { 
        $inc: { "seatsAvailable": -1 },
        $set: { "lastUpdated": new Date() }
    }
);

// Create ticket
db.tickets.insertOne({
    "eventId": ObjectId("507f1f77bcf86cd799439011"),
    "userId": ObjectId("507f1f77bcf86cd799439012"),
    "pricePaid": 100.00,
    "status": "active",
    "purchasedAt": new Date()
});

// Log activity
db.activity_log.insertOne({
    "action": "ticket_purchased",
    "eventId": ObjectId("507f1f77bcf86cd799439011"),
    "userId": ObjectId("507f1f77bcf86cd799439012"),
    "timestamp": new Date(),
    "details": {
        "pricePaid": 100.00,
        "seatsRemaining": 499
    }
});

// 10. Check transaction integrity
db.events.aggregate([
    {
        $lookup: {
            from: "tickets",
            localField: "_id",
            foreignField: "eventId",
            as: "tickets"
        }
    },
    {
        $project: {
            "title": 1,
            "seatsAvailable": 1,
            "ticketCount": { $size: "$tickets" },
            "totalSeats": { $add: ["$seatsAvailable", { $size: "$tickets" }] }
        }
    }
]);

// 11. Simulate ticket cancellation (reverse transaction)
// Find ticket to cancel
const ticketToCancel = db.tickets.findOne(
    { "status": "active" },
    { "eventId": 1, "pricePaid": 1 }
);

if (ticketToCancel) {
    // Restore seat
    db.events.updateOne(
        { "_id": ticketToCancel.eventId },
        { $inc: { "seatsAvailable": 1 } }
    );
    
    // Update ticket status
    db.tickets.updateOne(
        { "_id": ticketToCancel._id },
        { $set: { "status": "cancelled" } }
    );
}

// 12. Check for overselling (data integrity)
db.events.aggregate([
    {
        $lookup: {
            from: "tickets",
            localField: "_id",
            foreignField: "eventId",
            as: "tickets"
        }
    },
    {
        $project: {
            "title": 1,
            "seatsAvailable": 1,
            "ticketCount": { $size: "$tickets" },
            "oversold": {
                $gt: [
                    { $size: "$tickets" },
                    { $subtract: [1000, "$seatsAvailable"] }
                ]
            }
        }
    },
    {
        $match: { "oversold": true }
    }
]);

// 13. Simulate bulk ticket purchase
// This would be done in a transaction in a real application

// Check available seats
const event = db.events.findOne(
    { "_id": ObjectId("507f1f77bcf86cd799439011") },
    { "seatsAvailable": 1, "title": 1 }
);

if (event && event.seatsAvailable >= 5) {
    // Reserve 5 seats
    db.events.updateOne(
        { "_id": ObjectId("507f1f77bcf86cd799439011") },
        { $inc: { "seatsAvailable": -5 } }
    );
    
    // Create 5 tickets
    const tickets = [];
    for (let i = 0; i < 5; i++) {
        tickets.push({
            "eventId": ObjectId("507f1f77bcf86cd799439011"),
            "userId": ObjectId("507f1f77bcf86cd799439012"),
            "pricePaid": 100.00,
            "status": "active",
            "purchasedAt": new Date()
        });
    }
    
    db.tickets.insertMany(tickets);
}

// 14. Check transaction logs
db.activity_log.find(
    { "action": "ticket_purchased" },
    { "timestamp": 1, "details": 1 }
).sort({ "timestamp": -1 }).limit(10);

// 15. Simulate refund process
// Find a ticket to refund
const ticketToRefund = db.tickets.findOne(
    { "status": "active" },
    { "eventId": 1, "pricePaid": 1 }
);

if (ticketToRefund) {
    // Restore seat
    db.events.updateOne(
        { "_id": ticketToRefund.eventId },
        { $inc: { "seatsAvailable": 1 } }
    );
    
    // Update ticket status
    db.tickets.updateOne(
        { "_id": ticketToRefund._id },
        { $set: { "status": "refunded" } }
    );
    
    // Log refund
    db.activity_log.insertOne({
        "action": "ticket_refunded",
        "eventId": ticketToRefund.eventId,
        "userId": ObjectId("507f1f77bcf86cd799439012"),
        "timestamp": new Date(),
        "details": {
            "refundAmount": ticketToRefund.pricePaid
        }
    });
}

// 16. Check data consistency after operations
db.events.aggregate([
    {
        $lookup: {
            from: "tickets",
            localField: "_id",
            foreignField: "eventId",
            as: "tickets"
        }
    },
    {
        $project: {
            "title": 1,
            "seatsAvailable": 1,
            "activeTickets": {
                $size: {
                    $filter: {
                        input: "$tickets",
                        cond: { $eq: ["$$this.status", "active"] }
                    }
                }
            },
            "cancelledTickets": {
                $size: {
                    $filter: {
                        input: "$tickets",
                        cond: { $eq: ["$$this.status", "cancelled"] }
                    }
                }
            },
            "refundedTickets": {
                $size: {
                    $filter: {
                        input: "$tickets",
                        cond: { $eq: ["$$this.status", "refunded"] }
                    }
                }
            }
        }
    }
]);

// 17. Simulate concurrent access issues
// This would be handled by the application with proper locking

// 18. Check for orphaned records
db.tickets.aggregate([
    {
        $lookup: {
            from: "events",
            localField: "eventId",
            foreignField: "_id",
            as: "event"
        }
    },
    {
        $match: { "event": { $size: 0 } }
    },
    {
        $project: {
            "eventId": 1,
            "userId": 1,
            "status": 1
        }
    }
]);

// 19. Simulate data recovery
// Find tickets for non-existent events and clean them up
db.tickets.aggregate([
    {
        $lookup: {
            from: "events",
            localField: "eventId",
            foreignField: "_id",
            as: "event"
        }
    },
    {
        $match: { "event": { $size: 0 } }
    }
]);

// 20. Final consistency check
db.events.aggregate([
    {
        $lookup: {
            from: "tickets",
            localField: "_id",
            foreignField: "eventId",
            as: "tickets"
        }
    },
    {
        $project: {
            "title": 1,
            "seatsAvailable": 1,
            "totalTickets": { $size: "$tickets" },
            "activeTickets": {
                $size: {
                    $filter: {
                        input: "$tickets",
                        cond: { $eq: ["$$this.status", "active"] }
                    }
                }
            },
            "consistency": {
                $eq: [
                    { $add: ["$seatsAvailable", { $size: "$tickets" }] },
                    1000 // Assuming original capacity was 1000
                ]
            }
        }
    }
]);
